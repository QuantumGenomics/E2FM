/*
 * RandomGenerator.cpp
 *
 *  Created on: 20/dic/2014
 *      Author: fernando
 */

#include <stddef.h>
#include "RandomGenerator.h"
#include <algorithm>
#include "ecrypt-sync.h"
#include "Utils.h"
#include <iostream>

namespace std {

RandomGenerator::RandomGenerator(uint32_t keyStreamBufferSize,u8 *key, uint64_t nonce){
	this->keyStreamBufferSize=keyStreamBufferSize;
	this->key=key;
	this->nonce=nonce;
	this->counter=0;
	ecrypt_ctx= new ECRYPT_ctx();


	ECRYPT_init();  //initialize Salsa20/20 internal tables
	ECRYPT_keysetup(ecrypt_ctx,key,256,64);

	u8* iv=(u8*) &this->nonce; //the nonce is yet in little endian format (Intel platform)
	ECRYPT_ivsetup(ecrypt_ctx,iv);

	keyStreamBuffer=NULL;
	generatedBytes=0;
	liveBytes=0;
	liveBits=0;
}

RandomGenerator::RandomGenerator(uint32_t keyStreamBufferSize,u8 *key) {
	this->keyStreamBufferSize=keyStreamBufferSize;
	this->key=key;
	this->nonce=0;
	this->counter=0;

	ecrypt_ctx= new ECRYPT_ctx();

	ECRYPT_init();  //initialize Salsa20/20 internal tables
	ECRYPT_keysetup(ecrypt_ctx,key,256,64);

	keyStreamBuffer=NULL;
	generatedBytes=0;
	liveBytes=0;
	liveBits=0;
}

RandomGenerator::~RandomGenerator() {
	delete ecrypt_ctx;
	if (keyStreamBuffer!=NULL)
		delete[] keyStreamBuffer;
}

uint32_t RandomGenerator::nextInt(){
	uint32_t value= next(bitsToExtract);
	return value;
}

/**
 * Returns uniformly distributed integers in the range [0,n-1]
 * @param n
 */
uint32_t RandomGenerator::nextInt(uint32_t n){
	//number of bits to extract from the key stream buffer
	uint32_t bitsToExtract=Utils::int_log2(n-1);

	uint32_t val;
	do
		val = next(bitsToExtract);
	while (val > n-1);
	return val;
}


uint64_t RandomGenerator::nextInt64(uint32_t n){
	//TODO: implementare correttamente a 64 bit (per ora l'implementazione Ã¨ a 32 bit)
	//number of bits to extract from the key stream buffer
	uint32_t bitsToExtract=Utils::int_log2(n-1);

	uint64_t val;
	do
		val = next(bitsToExtract);
	while (val > n-1);
	return val;
}




uint32_t RandomGenerator::next(const uint32_t n) {
	uint32_t bsLiveShadow = this->liveBits;
	uint32_t bsBuffShadow = this->bitsBuffer;

	if (bsLiveShadow < n) {
		do {
			uint32_t thech = extractByteFromKeyStreamBuffer();

			bsBuffShadow = (bsBuffShadow << 8) | thech;
			bsLiveShadow += 8;
		} while (bsLiveShadow < n);

		this->bitsBuffer = bsBuffShadow;
	}

	this->liveBits = bsLiveShadow - n;
	return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1);
}


uint8_t RandomGenerator::extractByteFromKeyStreamBuffer() {
    	if (liveBytes == 0)
    		populateKeyStreamBuffer(keyStreamBufferSize);
    	uint8_t thech=keyStreamBuffer[generatedBytes -liveBytes];
    	liveBytes--;
    	return thech;
}


void RandomGenerator::populateKeyStreamBuffer(uint64_t nonce, uint32_t maxValue,uint64_t startValuePosition, uint64_t endValuePosition){
		this->nonce=nonce;

		ECRYPT_ivsetup(ecrypt_ctx,(u8*)&this->nonce);  //the nonce is in little endian format (Intel platform)

    	this->startValuePosition=startValuePosition;	//position of the first int value to generate
    	                                                //among all the int values in the keystream

    	/*
    	 * Each int value has a size (in bits) bitsToExtract=Math.ceil(log_2(maxIntValue+1)).
    	 *
    	 */
    	bitsToExtract=Utils::int_log2(maxValue+1);
    	uint64_t startOffsetInBits=startValuePosition*bitsToExtract;  //startValue is 0-based
    	uint64_t endOffsetInBits=(endValuePosition+1)*bitsToExtract;  //endValue is included in the range of the numbers to generate


    	uint64_t startValueBlockNumber=startOffsetInBits/512 ; //block number of the start int value between all the 64 byte blocks generated by Salsa20
    	uint64_t startValueBlockOffset=startOffsetInBits%512;  //offset (in bits) of the start int value between all the bits in that block
    	uint64_t endValueBlockNumber=endOffsetInBits/512;

    	this->counter=startValueBlockNumber;

    	uint64_t blocksToGenerate=endValueBlockNumber-startValueBlockNumber+1;
    	uint64_t bytesToGenerate=min(64*blocksToGenerate,(uint64_t)keyStreamBufferSize);
    	populateKeyStreamBuffer(bytesToGenerate);

    	gotoBlockOffset(startValueBlockOffset);

}


void RandomGenerator::populateKeyStreamBuffer(uint32_t bytesToGenerate){
	if (keyStreamBuffer!=NULL)
		delete[] keyStreamBuffer;
	keyStreamBuffer=new u8[bytesToGenerate];

	u8 *ctr=new u8[8];
	intToBigEndian(counter,ctr);
	ECRYPT_ctrsetup(ctr);

	u32 b=bytesToGenerate;
	ECRYPT_keystream_bytes(ecrypt_ctx, keyStreamBuffer,b);
	generatedBytes=bytesToGenerate;
	liveBytes=generatedBytes;

	delete[] ctr;
}


void RandomGenerator::ECRYPT_ctrsetup(const u8 *ctr)
{
  ecrypt_ctx->input[8] = U8TO32_BIG(ctr + 0);
  ecrypt_ctx->input[13] = U8TO32_BIG(ctr + 4);
}




void RandomGenerator::gotoBlockOffset(uint32_t startValueBlockOffset){
    	uint32_t byteNumber=startValueBlockOffset/8;
    	uint32_t bitNumber=startValueBlockOffset%8;
		//liveBytes=64-byteNumber;
    	liveBytes=generatedBytes-byteNumber;
		bitsBuffer=(short)keyStreamBuffer[generatedBytes -liveBytes]&0xFF;
		liveBytes--;
		liveBits=8-bitNumber;
}



void RandomGenerator::intToBigEndian(uint32_t n, uint8_t *bs){
	bs[0] = (uint8_t)(n >> 24);
	bs[1] = (uint8_t)(n >> 16);
	bs[2] = (uint8_t)(n >>  8);
	bs[3] = (uint8_t)n;
	bs[4]=0;
	bs[5]=0;
	bs[6]=0;
	bs[7]=0;
}








} /* namespace std */
